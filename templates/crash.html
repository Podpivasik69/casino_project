{% extends 'base.html' %}

{% block title %}Crash | SKET CASINO{% endblock %}

{% block content %}
{% csrf_token %}
<div class="game-room">
    <div class="game-header">
        <h2><i class="fas fa-rocket"></i> Crash</h2>
        <p>Множитель растет от 1.00x! Заберите деньги ДО краша!</p>
    </div>

    <!-- Compact Layout -->
    <div class="crash-layout">
        <!-- Left: Graph and Multiplier -->
        <div class="crash-main">
            <div class="multiplier-display" id="multiplierDisplay">
                <span id="multiplierValue">1.00</span>x
            </div>
            <div class="status-bar">
                <span id="statusText">Ожидание...</span>
                <span id="countdown"></span>
            </div>
            <div class="graph-container">
                <canvas id="crashGraph" width="600" height="200"></canvas>
            </div>
        </div>

        <!-- Right: Controls and History -->
        <div class="crash-sidebar">
            <!-- Bet Controls -->
            <div class="control-panel">
                <div class="input-row">
                    <label>Ставка:</label>
                    <input type="number" id="betAmount" value="10" min="0.01" max="1000" step="0.01">
                </div>
                <div class="input-row">
                    <label>Авто:</label>
                    <input type="number" id="autoCashout" min="1.01" step="0.01" placeholder="2.00x">
                </div>
                <button class="btn btn-primary" id="betButton" style="width: 100%; margin-bottom: 10px;">
                    <i class="fas fa-coins"></i> Поставить
                </button>
                <button class="btn btn-success" id="cashoutButton" disabled style="width: 100%;">
                    <i class="fas fa-hand-holding-usd"></i> Забрать
                </button>
            </div>

            <!-- Active Bets -->
            <div id="activeBetsSection" style="display: none;">
                <h4><i class="fas fa-list"></i> Ваши ставки</h4>
                <div id="activeBets"></div>
            </div>

            <!-- History -->
            <div class="history-panel">
                <h4><i class="fas fa-history"></i> История</h4>
                <div class="history-grid" id="historyContainer"></div>
            </div>
        </div>
    </div>
</div>

<style>
    .crash-layout {
        display: grid;
        grid-template-columns: 2fr 1fr;
        gap: 20px;
        margin-top: 20px;
    }

    .crash-main {
        background: linear-gradient(135deg, rgba(26, 26, 36, 0.95) 0%, rgba(13, 13, 20, 0.95) 100%);
        border: 1px solid rgba(16, 185, 129, 0.2);
        border-radius: var(--border-radius-lg);
        padding: 30px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 0 0 20px rgba(16, 185, 129, 0.1);
        position: relative;
        overflow: hidden;
    }

    .crash-main::before {
        content: '';
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: radial-gradient(circle, rgba(16, 185, 129, 0.05) 0%, transparent 70%);
        animation: rotate 20s linear infinite;
        pointer-events: none;
    }

    @keyframes rotate {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }

    .multiplier-display {
        font-family: 'Orbitron', sans-serif;
        font-size: 72px;
        font-weight: 900;
        text-align: center;
        margin-bottom: 15px;
        position: relative;
        z-index: 1;
        text-shadow: 0 0 20px currentColor, 0 0 40px currentColor;
        letter-spacing: 2px;
    }

    .multiplier-display.waiting { 
        color: var(--gray);
        animation: breathe 2s ease-in-out infinite;
    }
    
    .multiplier-display.active { 
        color: var(--primary);
        animation: glow-pulse 0.8s ease-in-out infinite, scale-up 0.3s ease-out;
    }
    
    .multiplier-display.crashed { 
        color: var(--danger);
        animation: crash-shake 0.5s ease-in-out, crash-fade 0.3s ease-out;
    }

    @keyframes breathe {
        0%, 100% { opacity: 0.6; transform: scale(1); }
        50% { opacity: 1; transform: scale(1.02); }
    }

    @keyframes glow-pulse {
        0%, 100% { 
            text-shadow: 0 0 20px currentColor, 0 0 40px currentColor, 0 0 60px currentColor;
            transform: scale(1);
        }
        50% { 
            text-shadow: 0 0 30px currentColor, 0 0 60px currentColor, 0 0 90px currentColor;
            transform: scale(1.05);
        }
    }

    @keyframes scale-up {
        from { transform: scale(0.8); opacity: 0; }
        to { transform: scale(1); opacity: 1; }
    }

    @keyframes crash-shake {
        0%, 100% { transform: translateX(0) rotate(0deg); }
        10%, 30%, 50%, 70%, 90% { transform: translateX(-10px) rotate(-2deg); }
        20%, 40%, 60%, 80% { transform: translateX(10px) rotate(2deg); }
    }

    @keyframes crash-fade {
        from { opacity: 1; }
        to { opacity: 0.3; }
    }

    .status-bar {
        text-align: center;
        font-size: 16px;
        font-weight: 600;
        color: var(--gray-light);
        margin-bottom: 20px;
        padding: 12px 20px;
        background: rgba(10, 10, 15, 0.6);
        border-radius: var(--border-radius);
        border: 1px solid rgba(255, 255, 255, 0.1);
        position: relative;
        z-index: 1;
    }

    #countdown {
        color: var(--primary);
        font-weight: 700;
        margin-left: 10px;
        font-size: 18px;
        animation: countdown-pulse 1s ease-in-out infinite;
    }

    @keyframes countdown-pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
    }

    .graph-container {
        background: linear-gradient(135deg, rgba(10, 10, 15, 0.9) 0%, rgba(5, 5, 10, 0.9) 100%);
        border-radius: var(--border-radius);
        padding: 15px;
        border: 1px solid rgba(16, 185, 129, 0.2);
        box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.5);
        position: relative;
        z-index: 1;
    }

    #crashGraph {
        width: 100%;
        height: auto;
        display: block;
        filter: drop-shadow(0 0 10px rgba(16, 185, 129, 0.3));
    }

    .crash-sidebar {
        display: flex;
        flex-direction: column;
        gap: 15px;
    }

    .control-panel {
        background: linear-gradient(135deg, rgba(26, 26, 36, 0.95) 0%, rgba(13, 13, 20, 0.95) 100%);
        border: 1px solid rgba(16, 185, 129, 0.2);
        border-radius: var(--border-radius-lg);
        padding: 25px;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
    }

    .input-row {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 18px;
    }

    .input-row label {
        color: var(--gray-light);
        font-size: 14px;
        font-weight: 600;
        min-width: 50px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .input-row input {
        flex: 1;
        padding: 12px 15px;
        background: rgba(10, 10, 15, 0.9);
        border: 2px solid rgba(16, 185, 129, 0.2);
        border-radius: var(--border-radius);
        color: var(--light);
        font-size: 16px;
        font-weight: 600;
        transition: all 0.3s ease;
    }

    .input-row input:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 15px rgba(16, 185, 129, 0.3);
        transform: translateY(-2px);
    }

    .btn {
        position: relative;
        overflow: hidden;
        transition: all 0.3s ease;
    }

    .btn::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 0;
        height: 0;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.2);
        transform: translate(-50%, -50%);
        transition: width 0.6s, height 0.6s;
    }

    .btn:active::before {
        width: 300px;
        height: 300px;
    }

    .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none !important;
    }

    .btn:not(:disabled):hover {
        transform: translateY(-3px);
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
    }

    #activeBetsSection {
        background: linear-gradient(135deg, rgba(26, 26, 36, 0.95) 0%, rgba(13, 13, 20, 0.95) 100%);
        border: 1px solid rgba(16, 185, 129, 0.2);
        border-radius: var(--border-radius-lg);
        padding: 20px;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
    }

    #activeBetsSection h4 {
        font-size: 14px;
        margin-bottom: 15px;
        color: var(--light);
        text-transform: uppercase;
        letter-spacing: 1px;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    #activeBets {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }

    .bet-item {
        background: rgba(10, 10, 15, 0.9);
        border-left: 3px solid var(--primary);
        border-radius: var(--border-radius);
        padding: 12px;
        font-size: 13px;
        transition: all 0.3s ease;
        animation: slide-in 0.3s ease-out;
    }

    @keyframes slide-in {
        from {
            opacity: 0;
            transform: translateX(-20px);
        }
        to {
            opacity: 1;
            transform: translateX(0);
        }
    }

    .bet-item:hover {
        transform: translateX(5px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }

    .bet-item.cashed_out { 
        border-left-color: var(--success);
        background: rgba(16, 185, 129, 0.1);
    }
    
    .bet-item.lost { 
        border-left-color: var(--danger);
        background: rgba(239, 68, 68, 0.1);
    }

    .bet-amount {
        font-weight: 700;
        margin-bottom: 5px;
        font-size: 14px;
    }

    .bet-potential {
        color: var(--primary);
        font-weight: 700;
        font-size: 15px;
        animation: pulse-glow 1s ease-in-out infinite;
    }

    @keyframes pulse-glow {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
    }

    .history-panel {
        background: linear-gradient(135deg, rgba(26, 26, 36, 0.95) 0%, rgba(13, 13, 20, 0.95) 100%);
        border: 1px solid rgba(16, 185, 129, 0.2);
        border-radius: var(--border-radius-lg);
        padding: 20px;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
    }

    .history-panel h4 {
        font-size: 14px;
        margin-bottom: 15px;
        color: var(--light);
        text-transform: uppercase;
        letter-spacing: 1px;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .history-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
    }

    .history-badge {
        padding: 10px;
        border-radius: var(--border-radius);
        text-align: center;
        font-weight: 700;
        font-size: 14px;
        font-family: 'Orbitron', sans-serif;
        cursor: pointer;
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
    }

    .history-badge::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        transition: left 0.5s;
    }

    .history-badge:hover::before {
        left: 100%;
    }

    .history-badge:hover {
        transform: scale(1.1) translateY(-2px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }

    .history-badge.low {
        background: linear-gradient(135deg, var(--success) 0%, #059669 100%);
        color: var(--light);
        box-shadow: 0 0 10px rgba(16, 185, 129, 0.3);
    }

    .history-badge.medium {
        background: linear-gradient(135deg, var(--warning) 0%, #D97706 100%);
        color: var(--light);
        box-shadow: 0 0 10px rgba(245, 158, 11, 0.3);
    }

    .history-badge.high {
        background: linear-gradient(135deg, var(--danger) 0%, #DC2626 100%);
        color: var(--light);
        box-shadow: 0 0 10px rgba(239, 68, 68, 0.3);
    }

    .crash-flash {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(circle, rgba(239, 68, 68, 0.4) 0%, transparent 70%);
        pointer-events: none;
        animation: crash-flash-anim 0.5s ease-out;
        z-index: 9999;
    }

    @keyframes crash-flash-anim {
        0% { opacity: 0; }
        20% { opacity: 1; }
        100% { opacity: 0; }
    }

    .success-particles {
        position: fixed;
        top: 50%;
        left: 50%;
        width: 10px;
        height: 10px;
        pointer-events: none;
        z-index: 9999;
    }

    .particle {
        position: absolute;
        width: 8px;
        height: 8px;
        background: var(--success);
        border-radius: 50%;
        animation: particle-burst 0.8s ease-out forwards;
        box-shadow: 0 0 10px var(--success);
    }

    @keyframes particle-burst {
        0% {
            transform: translate(0, 0) scale(1);
            opacity: 1;
        }
        100% {
            transform: translate(var(--tx), var(--ty)) scale(0);
            opacity: 0;
        }
    }

    @media (max-width: 1024px) {
        .crash-layout {
            grid-template-columns: 1fr;
        }
        
        .multiplier-display {
            font-size: 48px;
        }
        
        .history-grid {
            grid-template-columns: repeat(4, 1fr);
        }
    }
</style>

<script>
    // Get CSRF token from cookie or DOM
    function getCSRFToken() {
        // Try to get from cookie first
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, 10) === 'csrftoken=') {
                    cookieValue = decodeURIComponent(cookie.substring(10));
                    break;
                }
            }
        }
        
        // If not in cookie, try to get from DOM
        if (!cookieValue) {
            const csrfInput = document.querySelector('[name=csrfmiddlewaretoken]');
            if (csrfInput) {
                cookieValue = csrfInput.value;
            }
        }
        
        return cookieValue;
    }
    
    let currentRound = null;
    let currentMultiplier = 1.00;
    let roundStatus = 'waiting';
    let userBets = [];
    let pollingInterval = null;
    let multiplierInterval = null;
    let canvas = null;
    let ctx = null;
    let graphData = [];
    let roundStartTime = null;
    let lastServerMultiplier = 1.00;
    let lastServerUpdate = null;

    const POLLING_INTERVAL = 1000;  // Poll server every 1 second
    const MULTIPLIER_UPDATE_INTERVAL = 50;  // Update display every 50ms
    const API_BASE = '/api/games/crash';

    document.addEventListener('DOMContentLoaded', function() {
        canvas = document.getElementById('crashGraph');
        ctx = canvas.getContext('2d');
        
        document.getElementById('betButton').addEventListener('click', placeBet);
        document.getElementById('cashoutButton').addEventListener('click', cashout);
        
        loadHistory();
        startPolling();
    });

    function startPolling() {
        if (pollingInterval) clearInterval(pollingInterval);
        pollingInterval = setInterval(updateGameState, POLLING_INTERVAL);
        updateGameState();
    }

    async function updateGameState() {
        try {
            const response = await fetch(`${API_BASE}/current/`, {
                credentials: 'same-origin'
            });
            if (!response.ok) return;
            
            const data = await response.json();
            currentRound = data;
            roundStatus = data.status;
            
            if (roundStatus === 'waiting') {
                handleWaitingState(data);
            } else if (roundStatus === 'active') {
                handleActiveState(data);
            } else if (roundStatus === 'crashed') {
                handleCrashedState(data);
            }
        } catch (error) {
            console.error('Error updating game state:', error);
        }
    }

    function handleWaitingState(data) {
        stopMultiplierAnimation();
        roundStartTime = null;
        currentMultiplier = 1.00;
        
        document.getElementById('statusText').textContent = 'Ожидание раунда...';
        document.getElementById('countdown').textContent = `${data.seconds_until_start || 0}s`;
        document.getElementById('multiplierValue').textContent = '1.00';
        document.getElementById('multiplierDisplay').className = 'multiplier-display waiting';
        
        document.getElementById('betButton').disabled = false;
        document.getElementById('cashoutButton').disabled = true;
        
        clearGraph();
    }

    function handleActiveState(data) {
        // Update from server
        lastServerMultiplier = parseFloat(data.current_multiplier);
        lastServerUpdate = Date.now();
        
        // Start multiplier animation if not already running
        if (!multiplierInterval) {
            roundStartTime = Date.now();
            startMultiplierAnimation();
        }
        
        document.getElementById('multiplierDisplay').className = 'multiplier-display active';
        document.getElementById('statusText').textContent = 'Раунд активен!';
        document.getElementById('countdown').textContent = '';
        
        userBets = data.user_bets || [];
        updateBetsDisplay();
        
        const hasActiveBets = userBets.some(bet => bet.status === 'active');
        document.getElementById('betButton').disabled = hasActiveBets;
        document.getElementById('cashoutButton').disabled = !hasActiveBets;
    }
    
    function startMultiplierAnimation() {
        if (multiplierInterval) return;
        
        multiplierInterval = setInterval(() => {
            if (roundStatus !== 'active') {
                stopMultiplierAnimation();
                return;
            }
            
            // Calculate client-side multiplier based on elapsed time
            const elapsed = (Date.now() - roundStartTime) / 1000;  // seconds
            const calculatedMultiplier = Math.pow(1.06, elapsed);
            
            // Use server multiplier as reference, but smooth between updates
            currentMultiplier = calculatedMultiplier;
            
            // Cap at last known server multiplier + small buffer
            if (currentMultiplier > lastServerMultiplier + 0.5) {
                currentMultiplier = lastServerMultiplier + 0.5;
            }
            
            // Update display
            document.getElementById('multiplierValue').textContent = currentMultiplier.toFixed(2);
            
            // Update graph
            updateGraph(currentMultiplier);
            
            // Update potential winnings
            updateBetsDisplay();
            
        }, MULTIPLIER_UPDATE_INTERVAL);
    }
    
    function stopMultiplierAnimation() {
        if (multiplierInterval) {
            clearInterval(multiplierInterval);
            multiplierInterval = null;
        }
    }

    function handleCrashedState(data) {
        stopMultiplierAnimation();
        
        document.getElementById('statusText').textContent = `КРАШ! ${data.crash_point}x`;
        document.getElementById('multiplierValue').textContent = data.crash_point;
        document.getElementById('multiplierDisplay').className = 'multiplier-display crashed';
        document.getElementById('countdown').textContent = '';
        
        document.getElementById('betButton').disabled = true;
        document.getElementById('cashoutButton').disabled = true;
        
        playCrashAnimation();
        loadHistory();
        
        setTimeout(() => {
            userBets = [];
            updateBetsDisplay();
        }, 2000);
    }

    function updateBetsDisplay() {
        const container = document.getElementById('activeBets');
        const section = document.getElementById('activeBetsSection');
        
        if (userBets.length === 0) {
            section.style.display = 'none';
            return;
        }
        
        section.style.display = 'block';
        container.innerHTML = '';
        
        userBets.forEach(bet => {
            const betElement = document.createElement('div');
            betElement.className = `bet-item ${bet.status}`;
            
            let content = `<div class="bet-amount">${bet.bet_amount} ₽</div>`;
            
            if (bet.status === 'active') {
                // Calculate potential win using current multiplier
                const potentialWin = (parseFloat(bet.bet_amount) * currentMultiplier).toFixed(2);
                content += `<div class="bet-potential">${potentialWin} ₽ @ ${currentMultiplier.toFixed(2)}x</div>`;
                if (bet.auto_cashout_target) {
                    content += `<div style="font-size: 11px; color: var(--gray);">Авто: ${bet.auto_cashout_target}x</div>`;
                }
            } else if (bet.status === 'cashed_out') {
                content += `<div style="color: var(--success);">${bet.win_amount} ₽ (${bet.cashout_multiplier}x)</div>`;
            } else if (bet.status === 'lost') {
                content += `<div style="color: var(--danger);">Проиграно</div>`;
            }
            
            betElement.innerHTML = content;
            container.appendChild(betElement);
        });
    }

    async function placeBet() {
        const betAmount = parseFloat(document.getElementById('betAmount').value);
        const autoCashout = document.getElementById('autoCashout').value;
        
        if (!betAmount || betAmount < 0.01) {
            showMessage('Минимальная ставка: 0.01 ₽', 'error');
            return;
        }
        
        if (betAmount > 1000) {
            showMessage('Максимальная ставка: 1000 ₽', 'error');
            return;
        }
        
        const requestData = { amount: betAmount.toFixed(2) };
        if (autoCashout && parseFloat(autoCashout) >= 1.01) {
            requestData.auto_cashout_target = parseFloat(autoCashout).toFixed(2);
        }
        
        try {
            const response = await fetch(`${API_BASE}/bet/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCSRFToken()
                },
                credentials: 'same-origin',
                body: JSON.stringify(requestData)
            });
            
            const data = await response.json();
            
            if (!response.ok) {
                showMessage(data.error || 'Ошибка при размещении ставки', 'error');
                return;
            }
            
            updateBalance(data.balance);
            document.getElementById('betButton').disabled = true;
            updateGameState();
            showMessage('Ставка размещена!', 'success');
        } catch (error) {
            console.error('Error placing bet:', error);
            showMessage('Ошибка при размещении ставки', 'error');
        }
    }

    async function cashout() {
        const activeBet = userBets.find(bet => bet.status === 'active');
        if (!activeBet) {
            showMessage('Нет активных ставок', 'error');
            return;
        }
        
        try {
            const response = await fetch(`${API_BASE}/cashout/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCSRFToken()
                },
                credentials: 'same-origin',
                body: JSON.stringify({ bet_id: activeBet.id })
            });
            
            const data = await response.json();
            
            if (!response.ok) {
                showMessage(data.error || 'Ошибка при кэшауте', 'error');
                return;
            }
            
            updateBalance(data.balance);
            document.getElementById('cashoutButton').disabled = true;
            updateGameState();
            playSuccessAnimation();
            showMessage(`Выигрыш: ${data.win_amount} ₽ (${data.cashout_multiplier}x)`, 'success');
        } catch (error) {
            console.error('Error cashing out:', error);
            showMessage('Ошибка при кэшауте', 'error');
        }
    }

    async function loadHistory() {
        try {
            const response = await fetch(`${API_BASE}/history/`);
            if (!response.ok) return;
            
            const data = await response.json();
            displayHistory(data.rounds);
        } catch (error) {
            console.error('Error loading history:', error);
        }
    }

    function displayHistory(rounds) {
        const container = document.getElementById('historyContainer');
        container.innerHTML = '';
        
        rounds.slice(0, 15).forEach(round => {
            const crashPoint = parseFloat(round.crash_point);
            const badge = document.createElement('div');
            badge.className = 'history-badge';
            
            if (crashPoint < 2.0) {
                badge.classList.add('low');
            } else if (crashPoint < 5.0) {
                badge.classList.add('medium');
            } else {
                badge.classList.add('high');
            }
            
            badge.textContent = `${crashPoint.toFixed(2)}x`;
            container.appendChild(badge);
        });
    }

    function clearGraph() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        graphData = [];
        drawGrid();
    }

    function drawGrid() {
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        
        for (let i = 0; i <= 4; i++) {
            const y = (canvas.height / 4) * i;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
        }
    }

    function updateGraph(multiplier) {
        graphData.push(multiplier);
        if (graphData.length > 60) graphData.shift();
        
        clearGraph();
        if (graphData.length < 2) return;
        
        // Create gradient
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, '#10B981');
        gradient.addColorStop(0.5, '#34D399');
        gradient.addColorStop(1, '#6EE7B7');
        
        // Draw line
        ctx.strokeStyle = gradient;
        ctx.lineWidth = 3;
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#10B981';
        ctx.beginPath();
        
        const maxMultiplier = Math.max(...graphData, 2);
        const xStep = canvas.width / (graphData.length - 1);
        
        graphData.forEach((mult, index) => {
            const x = index * xStep;
            const y = canvas.height - (mult / maxMultiplier) * canvas.height * 0.9;
            
            if (index === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        });
        
        ctx.stroke();
        
        // Draw glow effect
        ctx.shadowBlur = 0;
        
        // Fill area under line
        ctx.lineTo(canvas.width, canvas.height);
        ctx.lineTo(0, canvas.height);
        ctx.closePath();
        
        const fillGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        fillGradient.addColorStop(0, 'rgba(16, 185, 129, 0.3)');
        fillGradient.addColorStop(1, 'rgba(16, 185, 129, 0.05)');
        ctx.fillStyle = fillGradient;
        ctx.fill();
    }

    function playCrashAnimation() {
        // Screen shake
        document.body.style.animation = 'crash-shake 0.5s ease-in-out';
        setTimeout(() => {
            document.body.style.animation = '';
        }, 500);
        
        // Red flash
        const flash = document.createElement('div');
        flash.className = 'crash-flash';
        document.body.appendChild(flash);
        
        setTimeout(() => flash.remove(), 500);
    }
    
    function playSuccessAnimation() {
        // Create particles
        const container = document.createElement('div');
        container.className = 'success-particles';
        document.body.appendChild(container);
        
        // Create 20 particles
        for (let i = 0; i < 20; i++) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            
            // Random direction
            const angle = (Math.PI * 2 * i) / 20;
            const distance = 100 + Math.random() * 100;
            const tx = Math.cos(angle) * distance;
            const ty = Math.sin(angle) * distance;
            
            particle.style.setProperty('--tx', `${tx}px`);
            particle.style.setProperty('--ty', `${ty}px`);
            
            container.appendChild(particle);
        }
        
        setTimeout(() => container.remove(), 800);
    }

    // showMessage, updateBalance, formatCurrency, and getCookie are defined in base.html

</script>
{% endblock %}
